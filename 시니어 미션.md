- 내용들을 간단하게 정리하여 주세요
    
    # 트랜잭션 상태
    
    ![스크린샷 2025-09-11 183721.png](attachment:be6e305d-5102-484d-a7f9-0d06107a1914:스크린샷_2025-09-11_183721.png)
    
    **상태 종류**: 활성(Active), 부분 완료(Partially Committed), 완료(Committed), 실패(Failed), 철회(Aborted)
    
    - **활성(Active)** : 트랜잭션이 **정상적으로 실행 중**인 상태를 의미한다.
    **트랜잭션이 시작**되면, 해당 트랜잭션의 상태는 **활동(Active)**상태가 된다. 해당 상태는 설계자가 설계한 대로 연산들이 정상적으로 실행중인 상태를 의미한다.
    
    ### 작업 성공 시
    
    - **부분 완료(Partially Committed)** : 트랜잭션의 마지막까지 실행되었지만, **Commit 연산이 실행되기 직전**의 상태
    - **완료(Committed)** : 트랜잭션이 **성공적으로 종료**되어 **Commit 연산을 실행한 후**의 상태
    
    설계된 트랜잭션대로 명령을 성공적으로 수행하면 그 다음 상태는 **부분적 완료(Partially Committed)**상태가 된다.
    
    설계된 작업대로 작업이 성공하였다고 하여 무조건 반영하는 것이 아니라, 설계자의 **최종 승인**(Commit)이 있을 때 까지 실제 데이터베이스에 작업 내용을 반영하지 않고 **기다린다**.
    
    설계자가 작업 결과에 대하여 반영을 승인(Commit)한다면 트랜잭션이 성공적으로 종료된다(Committed)
    
    ### 작업 실패 시
    
    - **실패(Failed)** : 트랜잭션 실행에 **오류가 발생**하여 **중단**된 상태.
    - **철회(Aborted)** : 트랜잭션이 **비정상적으로 종료**되어 **Rollback** 연산을 수행한 상태.
    
    트랜잭션을 수행하는 중간에 모종의 원인으로 인하여 오류가 발생하여 실행이 중단된 상태를 **실패(Failed)**상태라고 한다.
    
    이때 트랜잭션이 비정상적으로 종료되었으니, 설계되어있는 트랜잭션 내부의 작업을 다시 수행 이전의 상태로 돌리는 **ROLLBACK 연산**을 수행하면 그 상태를 **철회(Aborted)**라고 한다.
    
    > [참고자료] [https://inpa.tistory.com/entry/MYSQL-📚-트랜잭션Transaction-이란-💯-정리](https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)
    > 
    
    ---
    
    # 트랜잭션 전파
    
    - 이미 트랜잭션이 진행 중일 때 **추가 트랜잭션 진행**을 **어떻게 할지** 결정하는 것
    - Spring이 제공하는 선언적 트랜잭션(트랜잭션 어노테이션, `@Transactional`)의 장점 중 하나는 여러 트랜잭션을 묶어서 커다란 하나의 트랜잭션 경계를 만들 수 있다는 점이다.
    - 작업을 하다보면 기존에 **트랜잭션이 진행 중일** 때 **추가적인 트랜잭션을 진행**해야 하는 경우가 있다.
    
    ## 1. 물리 트랜잭션과 논리 트랜잭션
    
    ### 물리 트랜잭션
    
    - 데이터베이스가 직접 인식하고 실행하는 실제 트랜잭션
    - 데이터베이스 **커넥션(Connection)** 객체를 통해 제어되며, `COMMIT` 또는 `ROLLBACK`이 호출되는 가장 기본적인 트랜잭션 단위
    - DB 커넥션(Connection) 이란?
        - 애플리케이션이 데이터베이스와 통신하기 위해 사용하는 **연결 통로**
        - 데이터를 읽거나 쓰기(CRUD) 위한 모든 작업은 반드시 이 **커넥션**을 통해서만 수행
        - 인증(Authentication), 세션 생성, SQL 실행 및 결과 수신 등의 작업을 수행
        
        하지만, 매번 DB와의 연결을 위해 커넥션을 새로 만드는 것은 비효율적이므로 커넥션 풀을 사용
        
        ### 커넥션 풀(Pool)
        
        - 미리 일정 개수의 DB 커넥션을 만들어두고 풀에 저장해 둔 뒤, 애플리케이션의 요청이 있을 때마다 이 풀에서 커넥션을 빌려주고, 작업이 끝나면 다시 반납 받아 재사용하는 방식
    
    ### 논리 트랜잭션
    
    - 애플리케이션 레벨(예: 스프링)에서 인식하는 트랜잭션 범위
    - 주로 `@Transactional` 어노테이션이 붙은 메서드 하나하나가 하나의 논리 트랜잭션에 해당
    
    ### @Transactional 의 동작과정
    
    1. DB 커넥션(Connection) 풀에서 커넥션 하나 대여
    2. 물리 트랜잭션 시작
    3. 물리 트랜잭션 종료(Commit or Rollback)
    4. DB 커넥션 풀에 커넥션 반납
    
    ### 원칙
    
    - 논리 트랜잭션은 물리 트랜잭션 **내부에서 작동**함
    - **모든 논리 트랜잭션이 커밋**되어야 **물리 트랜잭션이 커밋**됨
    - **하나의 논리 트랜잭션이라도 롤백**되면 **물리 트랜잭션은 롤백**됨
    
    트랜잭션 내부에 트랜잭션이 발생할 경우, 즉 하나의 트랜잭션이 동작하고 있는데, 동작 과정 중에 다른 트랜잭션이 실행될 경우, 논리 트랜잭션이 한 개 더 생성된다.
    
    **트랜잭션 전파는 바로 이 논리 트랜잭션들이 어떻게 하나의 물리 트랜잭션으로 묶일지를 결정하는 규칙을 말한다.**
    
    ## 2. 트랜잭션 전파 속성
    
    스프링에는 7가지 전파 속성이 존재한다.
    
    - `REQUIRED`, `SUPPORTS`, `MANDATORY`, `REQUIRES_NEW`, `NOT_SUPPORTED`, `NEVER`, `NESTED`
    
    ### **REQUIRED 속성과 REQUIRES_NEW 속성**
    
    **REQUIRED**
    
    - 스프링이 제공하는 **기본적인(DEFAULT)** 전파 속성
    - 기본적으로 2개의 논리 트랜잭션을 묶어 1개의 물리 트랜잭션을 사용
    - 새롭게 생성된 논리 트랜잭션은 기존에 존재하는 물리 트랜잭션에 **참여**함
        - 새로운 물리 트랜잭션이 생성되지 않음
    
    ![트랜잭션 전파1.png](attachment:d93241a9-6a89-47a0-81ef-9842146d2251:트랜잭션_전파1.png)
    
    **REQUIRES_NEW**
    
    - REQUIRES_NEW는 외부 트랜잭션과 내부 트랜잭션을 **완전히 분리**하는 전파 속성
    - 2개 이상의 물리 트랜잭션이 사용되며, 각각 트랜잭션 별로 커밋과 롤백이 수행됨
    - 서로 다른 물리 트랜잭션이므로, 내부 트랜잭션 롤백이 외부 트랜잭션 롤백에 영향을 주지 않음
    
    ![트랜잭션 전파2.png](attachment:c0cb8567-7090-4e49-abda-1a94dfce1c12:트랜잭션_전파2.png)
    
    ## 정리
    
    - 속성 (Propagation Level)설명 by Gemini
        
        **`REQUIRED` (기본값)**
        
        **(가장 일반적인 옵션)**
        
        - 부모 트랜잭션이 이미 존재하면 해당 트랜잭션에 참여하고, 존재하지 않으면 새로운 트랜잭션을 생성합니다. 하나의 묶음으로 처리되므로, 내부 트랜잭션에서 문제가 발생하면 전체가 롤백됩니다.
        
        **`REQUIRES_NEW`**
        
        - 부모 트랜잭션의 존재 여부와 상관없이 **항상 새로운 트랜잭션을 생성**합니다. 부모 트랜잭션은 새로운 트랜잭션이 끝날 때까지 대기하며, 서로 영향을 주지 않습니다. (예: 로그 기록 등 필수적으로 성공해야 하는 작업에 사용)
        
        **`NESTED`**
        
        - 부모 트랜잭션이 존재하면 **중첩된 트랜잭션(savepoint)**을 만듭니다. 중첩 트랜잭션은 독립적으로 롤백이 가능하지만, 커밋은 부모 트랜잭션에 의해 최종 결정됩니다. 부모 트랜잭션이 롤백되면 중첩 트랜잭션도 함께 롤백됩니다.
        
        **`SUPPORTS`**
        
        - 부모 트랜잭션이 존재하면 해당 트랜잭션에 참여하지만, 없으면 트랜잭션 없이 로직을 실행합니다.
        
        **`NOT_SUPPORTED`**
        
        - 부모 트랜잭션이 존재하더라도 트랜잭션 없이 로직을 실행합니다. (트랜잭션을 일시적으로 중지시킴)
        
        **`MANDATORY`**
        
        - **반드시 부모 트랜잭션이 존재해야**하며, 없으면 예외를 발생시킵니다. 독립적으로 실행되어서는 안 되는 로직에 사용됩니다.
        
        **`NEVER`**
        
        - **반드시 트랜잭션이 없어야**하며, 부모 트랜잭션이 존재하면 예외를 발생시킵니다.
    
    ![트랜잭션 전파.png](attachment:b5fa39b9-711f-433a-9b2a-cdea8078e33e:트랜잭션_전파.png)
    
    > [참고자료] https://mangkyu.tistory.com/269
    >
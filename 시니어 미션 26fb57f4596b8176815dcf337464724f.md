# 시니어 미션

![내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함)](Untitled.png)

내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함)

- [x]  미션 1(내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함))에서
정렬 기준을 1순위는 포인트로 2순위는 최신순으로 하여 Cursor기반 페이지네이션을 구현해보세요!
    
    ```sql
    select l.name, u.point, s.name, m.deadline, m.conditional, m.point,
    			CONCAT(LPAD(m.point, 10, '0'), DATE_FORMAT(m.created_at, '%Y%m%d%H%i%s%f'), LPAD(m.mission_id, 10, '0')) as cursor_value,
    			(select count(*) from location as l
    				left join store as s on s.location_id = l.location_id
    				left join mission as m on m.store_id = s.store_id
    				left join user_mission as um on um.mission_id = m.mission_id
    				left join user as u on u.user_id = um.user_id
    				where l.name = '안암동' and um.is_complete = 1 and u.user_id = 1) as complete_cnt
    from location as l
    left join store as s on s.location_id = l.location_id
    left join mission as m on m.store_id = s.store_id
    left join user_mission as um on um.mission_id = m.mission_id
    left join user as u on u.user_id = um.user_id
    where l.name = '안암동' and um.is_complete = 0 and u.user_id = 1
    		 and CONCAT(LPAD(m.point, 10, '0'), DATE_FORMAT(m.created_at, '%Y%m%d%H%i%s%f'), LPAD(m.mission_id, 10, '0')) < '00000005202509011010101234560000000010'
    order by m.point desc, m.created_at desc, m.mission_id desc
    limit 10;
    ```
    
    - 내용들을 간단하게 정리하여주세요
        
        커서 조건 - 포인트: 500점, 등록일자: 2025년 09월 01일 10시 10분 10초 123456ms, mission_id: 10
        
        mission 테이블의 created_at 칼럼은 LocalDateTime이기 때문에 DATE_FORMAT()을 사용하여 문자열로 변환 후 CONCAT 수행. %f로 6자리의 ms까지 문자열로 변환
        
        정렬 조건의 포인트와 최신순은 Unique 칼럼이 아니여서 기본키 칼럼을 커서에 추가함.
        

- [ ]  다양한 트랜젝션 상태와, 트랜젝션 전파에 대해 조사해주세요!
    - 내용들을 간단하게 정리하여 주세요
        
        # 트랜잭션 상태
        
        ![스크린샷 2025-09-11 183721.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-09-11_183721.png)
        
        **상태 종류**: 활성(Active), 부분 완료(Partially Committed), 완료(Committed), 실패(Failed), 철회(Aborted)
        
        - **활성(Active)** : 트랜잭션이 **정상적으로 실행 중**인 상태를 의미한다.
        **트랜잭션이 시작**되면, 해당 트랜잭션의 상태는 **활동(Active)**상태가 된다. 해당 상태는 설계자가 설계한 대로 연산들이 정상적으로 실행중인 상태를 의미한다.
        
        ### 작업 성공 시
        
        - **부분 완료(Partially Committed)** : 트랜잭션의 마지막까지 실행되었지만, **Commit 연산이 실행되기 직전**의 상태
        - **완료(Committed)** : 트랜잭션이 **성공적으로 종료**되어 **Commit 연산을 실행한 후**의 상태
        
        설계된 트랜잭션대로 명령을 성공적으로 수행하면 그 다음 상태는 **부분적 완료(Partially Committed)**상태가 된다.
        
        설계된 작업대로 작업이 성공하였다고 하여 무조건 반영하는 것이 아니라, 설계자의 **최종 승인**(Commit)이 있을 때 까지 실제 데이터베이스에 작업 내용을 반영하지 않고 **기다린다**.
        
        설계자가 작업 결과에 대하여 반영을 승인(Commit)한다면 트랜잭션이 성공적으로 종료된다(Committed)
        
        ### 작업 실패 시
        
        - **실패(Failed)** : 트랜잭션 실행에 **오류가 발생**하여 **중단**된 상태.
        - **철회(Aborted)** : 트랜잭션이 **비정상적으로 종료**되어 **Rollback** 연산을 수행한 상태.
        
        트랜잭션을 수행하는 중간에 모종의 원인으로 인하여 오류가 발생하여 실행이 중단된 상태를 **실패(Failed)**상태라고 한다.
        
        이때 트랜잭션이 비정상적으로 종료되었으니, 설계되어있는 트랜잭션 내부의 작업을 다시 수행 이전의 상태로 돌리는 **ROLLBACK 연산**을 수행하면 그 상태를 **철회(Aborted)**라고 한다.
        
        > [참고자료] [https://inpa.tistory.com/entry/MYSQL-📚-트랜잭션Transaction-이란-💯-정리](https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)
        > 
        
        ---
        
        # 트랜잭션 전파
        
        - 이미 트랜잭션이 진행 중일 때 **추가 트랜잭션 진행**을 **어떻게 할지** 결정하는 것
        - Spring이 제공하는 선언적 트랜잭션(트랜잭션 어노테이션, `@Transactional`)의 장점 중 하나는 여러 트랜잭션을 묶어서 커다란 하나의 트랜잭션 경계를 만들 수 있다는 점이다.
        - 작업을 하다보면 기존에 **트랜잭션이 진행 중일** 때 **추가적인 트랜잭션을 진행**해야 하는 경우가 있다.
        
        ## 1. 물리 트랜잭션과 논리 트랜잭션
        
        ### 물리 트랜잭션
        
        - 데이터베이스가 직접 인식하고 실행하는 실제 트랜잭션
        - 데이터베이스 **커넥션(Connection)** 객체를 통해 제어되며, `COMMIT` 또는 `ROLLBACK`이 호출되는 가장 기본적인 트랜잭션 단위
        - DB 커넥션(Connection) 이란?
            - 애플리케이션이 데이터베이스와 통신하기 위해 사용하는 **연결 통로**
            - 데이터를 읽거나 쓰기(CRUD) 위한 모든 작업은 반드시 이 **커넥션**을 통해서만 수행
            - 인증(Authentication), 세션 생성, SQL 실행 및 결과 수신 등의 작업을 수행
            
            하지만, 매번 DB와의 연결을 위해 커넥션을 새로 만드는 것은 비효율적이므로 커넥션 풀을 사용
            
            ### 커넥션 풀(Pool)
            
            - 미리 일정 개수의 DB 커넥션을 만들어두고 풀에 저장해 둔 뒤, 애플리케이션의 요청이 있을 때마다 이 풀에서 커넥션을 빌려주고, 작업이 끝나면 다시 반납 받아 재사용하는 방식
        
        ### 논리 트랜잭션
        
        - 애플리케이션 레벨(예: 스프링)에서 인식하는 트랜잭션 범위
        - 주로 `@Transactional` 어노테이션이 붙은 메서드 하나하나가 하나의 논리 트랜잭션에 해당
        
        ### @Transactional 의 동작과정
        
        1. DB 커넥션(Connection) 풀에서 커넥션 하나 대여
        2. 물리 트랜잭션 시작
        3. 물리 트랜잭션 종료(Commit or Rollback)
        4. DB 커넥션 풀에 커넥션 반납
        
        ### 원칙
        
        - 논리 트랜잭션은 물리 트랜잭션 **내부에서 작동**함
        - **모든 논리 트랜잭션이 커밋**되어야 **물리 트랜잭션이 커밋**됨
        - **하나의 논리 트랜잭션이라도 롤백**되면 **물리 트랜잭션은 롤백**됨
        
        트랜잭션 내부에 트랜잭션이 발생할 경우, 즉 하나의 트랜잭션이 동작하고 있는데, 동작 과정 중에 다른 트랜잭션이 실행될 경우, 논리 트랜잭션이 한 개 더 생성된다.
        
        **트랜잭션 전파는 바로 이 논리 트랜잭션들이 어떻게 하나의 물리 트랜잭션으로 묶일지를 결정하는 규칙을 말한다.**
        
        ## 2. 트랜잭션 전파 속성
        
        스프링에는 7가지 전파 속성이 존재한다.
        
        - `REQUIRED`, `SUPPORTS`, `MANDATORY`, `REQUIRES_NEW`, `NOT_SUPPORTED`, `NEVER`, `NESTED`
        
        ### **REQUIRED 속성과 REQUIRES_NEW 속성**
        
        **REQUIRED**
        
        - 스프링이 제공하는 **기본적인(DEFAULT)** 전파 속성
        - 기본적으로 2개의 논리 트랜잭션을 묶어 1개의 물리 트랜잭션을 사용
        - 새롭게 생성된 논리 트랜잭션은 기존에 존재하는 물리 트랜잭션에 **참여**함
            - 새로운 물리 트랜잭션이 생성되지 않음
        
        ![트랜잭션 전파1.png](%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98_%EC%A0%84%ED%8C%8C1.png)
        
        **REQUIRES_NEW**
        
        - REQUIRES_NEW는 외부 트랜잭션과 내부 트랜잭션을 **완전히 분리**하는 전파 속성
        - 2개 이상의 물리 트랜잭션이 사용되며, 각각 트랜잭션 별로 커밋과 롤백이 수행됨
        - 서로 다른 물리 트랜잭션이므로, 내부 트랜잭션 롤백이 외부 트랜잭션 롤백에 영향을 주지 않음
        
        ![트랜잭션 전파2.png](%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98_%EC%A0%84%ED%8C%8C2.png)
        
        ## 정리
        
        - 속성 (Propagation Level)설명 by Gemini
            
            **`REQUIRED` (기본값)**
            
            **(가장 일반적인 옵션)**
            
            - 부모 트랜잭션이 이미 존재하면 해당 트랜잭션에 참여하고, 존재하지 않으면 새로운 트랜잭션을 생성합니다. 하나의 묶음으로 처리되므로, 내부 트랜잭션에서 문제가 발생하면 전체가 롤백됩니다.
            
            **`REQUIRES_NEW`**
            
            - 부모 트랜잭션의 존재 여부와 상관없이 **항상 새로운 트랜잭션을 생성**합니다. 부모 트랜잭션은 새로운 트랜잭션이 끝날 때까지 대기하며, 서로 영향을 주지 않습니다. (예: 로그 기록 등 필수적으로 성공해야 하는 작업에 사용)
            
            **`NESTED`**
            
            - 부모 트랜잭션이 존재하면 **중첩된 트랜잭션(savepoint)**을 만듭니다. 중첩 트랜잭션은 독립적으로 롤백이 가능하지만, 커밋은 부모 트랜잭션에 의해 최종 결정됩니다. 부모 트랜잭션이 롤백되면 중첩 트랜잭션도 함께 롤백됩니다.
            
            **`SUPPORTS`**
            
            - 부모 트랜잭션이 존재하면 해당 트랜잭션에 참여하지만, 없으면 트랜잭션 없이 로직을 실행합니다.
            
            **`NOT_SUPPORTED`**
            
            - 부모 트랜잭션이 존재하더라도 트랜잭션 없이 로직을 실행합니다. (트랜잭션을 일시적으로 중지시킴)
            
            **`MANDATORY`**
            
            - **반드시 부모 트랜잭션이 존재해야**하며, 없으면 예외를 발생시킵니다. 독립적으로 실행되어서는 안 되는 로직에 사용됩니다.
            
            **`NEVER`**
            
            - **반드시 트랜잭션이 없어야**하며, 부모 트랜잭션이 존재하면 예외를 발생시킵니다.
        
        ![트랜잭션 전파.png](%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98_%EC%A0%84%ED%8C%8C.png)
        
        > [참고자료] [https://mangkyu.tistory.com/269](https://mangkyu.tistory.com/269)
        > 
    

- [x]  함수 기반 인덱스와 복합 인덱스에 대해 조사하고,
성능상 이점과 단점을 적어주세요!
    - 내용들을 간단하게 정리하여 주세요
        
        # 함수 기반 인덱스
        
        칼럼에 변형이 생기는 경우, 즉 함수 등을 사용하여 기존 테이블에 있는 칼럼이 아니게 된 경우에는 기존의 인덱스를 사용하지 못한다.
        
        이 경우 함수 기반 인덱스(FBI, Funtion-Based Index)를 사용하면 칼럼에 함수나 표현식을 사용해도 사용 할 수 있는 인덱스를 생성할 수 있다.
        
        ### 기존 인덱스 사용법
        
        ```sql
        CREATE INDEX idx_user ON user(email);
        SELECT user.* FROM user WHERE user.email = 'abc@gmail.com';
        ```
        
        위의 쿼리에서 `email` 칼럼을 사용하여 단일 인덱스를 생성했기 때문에 `where` 절에서 `email` 데이터를 검색 시, 만들어 놓은 인덱스를 기반으로 검색을 수행하게 된다.
        
        하지만, 
        
        ```sql
        SELECT user.* FROM user WHERE CONCAT('abc', '@gmail.com');
        ```
        
        와 같이 `where` 절에서 함수를 사용한 경우, 기존에 생성한 인덱스에서는 탐색을 수행할 수 없다.
        
        그렇기에 함수 기반 인덱스를 생성한다.
        
        ```sql
        CREATE INDEX fbi_user ON CONCAT('abc', '@gmail.com');
        ```
        
        함수를 인덱스로 만들어 놓는다면, 이후 함수를 기반으로 `where` 쿼리가 요청되어도 인덱스를 기반으로 탐색을 수행 할 수 있게 된다.
        
        ### 장점
        
        - 함수 값에 대한 인덱스 탐색 가능
        - 인덱스 칼럼이 `where`절에서 변형되어도 인덱스 이용 가능
        
        ### 단점
        
        - DML 작업 시 성능 저하(매번 함수를 실행시켜야 하기 때문)
        - `where`절에 사용된 함수나 표현식이 인덱스에 정의된 것과 정확히 일치해야만 인덱스를 사용 가능
        
        ## 가상 칼럼 인덱스
        
        - 변형된 칼럼을 생성하여 인덱스로 사용하는 방법
        
        함수 기반 인덱스는 함수 자체를 인덱스로 생성하는 방식이고,
        
        가상 칼럼 인덱스는 함수의 결과를 칼럼으로 생성하고, 그 칼럼을 인덱스로 생성하는 방식이다.
        
        Ex)
        
        ```sql
        CONCAT(LPAD(m.point, 10, '0'), ..., LPAD(m.mission_id, 10, '0')) as cursor_value
        ```
        
        위 쿼리는 커서 기반 페이징에서 사용한 `cursor_value` 데이터를 만드는 함수이다.
        
        이 `cursor_value` 데이터를 가상 칼럼으로 생성하고 인덱스로 생성하는 방식이 가상 칼럼 인덱스이다.
        
        ```sql
        ALTER TABLE USER
        		ADD cursor_value VARCHAR(50) AS (CONCAT(LPAD(), ...생략)) VIRTUAL,
        		ADD INDEX idx_cursor (cursor_value);
        ```
        
        # 복합 인덱스
        
        두 개 이상의 칼럼을 조합해서 인덱스로 만들어 사용하는 방식으로, 여러 칼럼이 `where` 절의 조건으로 자주 함께 사용될 때 효과적이다.
        
        ### 인덱스로 생성하려는 칼럼이 여러 개인 경우
        
        단일 인덱스를 여러 개 생성하게 되면, `where` 절에서 칼럼이 여러 개 일 때, 각각의 생성된 여러 인덱스를 모두 돌아야 한다.
        
        반면에, 복합 인덱스를 사용하여 여러 개의 칼럼을 하나의 인덱스로 생성한다면, 하나의 인덱스 안에서만 인덱스 탐색이 진행되기 때문에 단일 인덱스를 여러 개 생성하는 것보다 효율적이다.
        
        ```sql
        /* 단일 인덱스 여러 개 */
        CREATE INDEX idx_user1 ON user(email);
        CREATE INDEX idx_user2 ON user(user_id);
        
        /* 복합 인덱스 한 개 */
        CREATE INDEX idx_user ON user(email, user_id);
        ```
        
        ### 장점
        
        - **검색 속도 개선**
            
            여러 개의 칼럼을 동시에 검색할 수 있기 때문에 검색 속도가 개선할 수 있다.
            
        - **데이터 정렬의 효율성**
            
            인덱스를 생성할 때 여러 개의 칼럼을 함께 사용하면 정렬을 할 때 더 효율적으로 할 수 있다.
            
        - **인덱스의 용량 절감**
            
            인덱스를 생성할 때 여러 개의 칼럼을 함께 사용하면 인덱스의 용량이 줄어든다.
            
        - **쿼리 최적화**
            
            복합 인덱스는 여러 개의 칼럼을 함께 사용하기 때문에, 쿼리가 여러 개의 조건을 가지고 있을 때 최적화된 실행 계획을 수립할 수 있다.
            
        
        ### 주의사항
        
        - 복합 인덱스를 생성할 때는 **인덱스 생성 순서**도 고려해야 한다.
            
            쿼리 문 작성 시 복합 인덱스를 사용하고자 한다면 반드시 복합 인덱스의 칼럼 중 선행하는 칼럼부터 조건에 지정하여 사용하여야 한다. 주로 자주 이용되는 순서대로 복합 인덱스 칼럼의 순서 결정한다.
            
        
        복합 인덱스를 생성하게 되면, 작성한 칼럼 순서대로 인덱스가 만들어진다. 
        
        ![[1, Bomb, ardier], [2, Airbus, A319] … 의 데이터가 저장된 복합 인덱스의 B-Tree 구조](%EB%B3%B5%ED%95%A9_%EC%9D%B8%EB%8D%B1%EC%8A%A4_B-Tree.png)
        
        [1, Bomb, ardier], [2, Airbus, A319] … 의 데이터가 저장된 복합 인덱스의 B-Tree 구조
        
        > [사진 출처] [https://postgrespro.com/blog/pgsql/4161516](https://postgrespro.com/blog/pgsql/4161516)
        > 
        
        B-Tree 구조에서 데이터는 복합 인덱스 생성 당시 순서의 칼럼대로 정렬된다.
        
        ```sql
        CREATE INDEX idx_user ON user(email, user_id);
        ```
        
        위의 칼럼대로 복합 인덱스를 생성한 경우, `email` 데이터를 기준으로 먼저 정렬이 되고, `email` 데이터가 같다면 `user_id` 데이터를 기준으로 정렬이 진행된다.
        
        그러므로, 인덱스를 탐색하기 위해서는 첫 번째 순서의 `email` 데이터를 `where` 절에 먼저 위치시켜야 제대로 된 인덱스 탐색이 가능하다.
        
        만약 `where` 절에 `user_id` 데이터만 작성한다면, Tree 구조로 탐색을 진행하지 못하기 때문에 인덱스 전체를 탐색하게 된다.
        
        - Tree 구조로 탐색하지 못하는 이유
            
            Tree 구조 탐색이 효율적인 이유는 정렬이 된 상태이기 때문이다. 
            
            현재 노드의 데이터를 기반으로 작으면 왼쪽으로, 크면 오른쪽으로 다음 탐색이 진행된다.
            
            - Ex) `[1, Bomb, ardier]` 에서 첫 번째 칼럼 데이터인 ‘1’보다 작거나 같은 데이터인 `[1, Censsna 208]` 데이터는 `[1, Bomb, ardier]` 노드 좌측에 위치한다.
            
            복합 인덱스 B-Tree의 경우 첫 번째 칼럼을 기준으로 정렬이 진행되었기 때문에 두 번째 칼럼으로는 Tree 탐색이 불가능하다.
            
        
        ```sql
        WHERE email = 'abc@gmail.com';     //제대로 된 인덱스 탐색(Tree 구조 탐색)
        WHERE user_id = 1;                 //인덱스 전체 탐색(1 ~ N 까지 모두 탐색)
        ```
        
        - 인덱스 생성 순서는 WHERE 절에서 **먼저 사용되는 칼럼을 앞쪽에 위치**시키는 것이 좋다.
            
            이렇게 함으로써, 인덱스를 탐색할 때 필요한 레코드 수가 최소화시킬 수 있다.
            

정리된 글을 바탕으로 블로그를 작성하여 주세요